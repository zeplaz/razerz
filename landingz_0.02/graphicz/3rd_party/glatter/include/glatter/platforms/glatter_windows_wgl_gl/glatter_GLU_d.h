/*
Copyright 2018 Ioannis Makris

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// This file was generated by glatter.py script.



#ifdef GLATTER_GLU
#if defined(__glu_h__)
#if defined(__GLU_H__)
#ifndef gluBeginCurve
#define gluBeginCurve(nobj) glatter_gluBeginCurve_debug((nobj), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluBeginCurve_debug(GLUnurbs *nobj, const char* file, int line);
#ifndef gluBeginPolygon
#define gluBeginPolygon(tess) glatter_gluBeginPolygon_debug((tess), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluBeginPolygon_debug(GLUtesselator *tess, const char* file, int line);
#ifndef gluBeginSurface
#define gluBeginSurface(nobj) glatter_gluBeginSurface_debug((nobj), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluBeginSurface_debug(GLUnurbs *nobj, const char* file, int line);
#ifndef gluBeginTrim
#define gluBeginTrim(nobj) glatter_gluBeginTrim_debug((nobj), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluBeginTrim_debug(GLUnurbs *nobj, const char* file, int line);
#ifndef gluBuild1DMipmaps
#define gluBuild1DMipmaps(target, components, width, format, type, data) glatter_gluBuild1DMipmaps_debug((target), (components), (width), (format), (type), (data), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT int glatter_gluBuild1DMipmaps_debug(GLenum target, GLint components, GLint width, GLenum format, GLenum type, const void *data, const char* file, int line);
#ifndef gluBuild2DMipmaps
#define gluBuild2DMipmaps(target, components, width, height, format, type, data) glatter_gluBuild2DMipmaps_debug((target), (components), (width), (height), (format), (type), (data), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT int glatter_gluBuild2DMipmaps_debug(GLenum target, GLint components, GLint width, GLint height, GLenum format, GLenum type, const void *data, const char* file, int line);
#ifndef gluCylinder
#define gluCylinder(qobj, baseRadius, topRadius, height, slices, stacks) glatter_gluCylinder_debug((qobj), (baseRadius), (topRadius), (height), (slices), (stacks), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluCylinder_debug(GLUquadric *qobj, GLdouble baseRadius, GLdouble topRadius, GLdouble height, GLint slices, GLint stacks, const char* file, int line);
#ifndef gluDeleteNurbsRenderer
#define gluDeleteNurbsRenderer(nobj) glatter_gluDeleteNurbsRenderer_debug((nobj), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluDeleteNurbsRenderer_debug(GLUnurbs *nobj, const char* file, int line);
#ifndef gluDeleteQuadric
#define gluDeleteQuadric(state) glatter_gluDeleteQuadric_debug((state), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluDeleteQuadric_debug(GLUquadric *state, const char* file, int line);
#ifndef gluDeleteTess
#define gluDeleteTess(tess) glatter_gluDeleteTess_debug((tess), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluDeleteTess_debug(GLUtesselator *tess, const char* file, int line);
#ifndef gluDisk
#define gluDisk(qobj, innerRadius, outerRadius, slices, loops) glatter_gluDisk_debug((qobj), (innerRadius), (outerRadius), (slices), (loops), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluDisk_debug(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, const char* file, int line);
#ifndef gluEndCurve
#define gluEndCurve(nobj) glatter_gluEndCurve_debug((nobj), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluEndCurve_debug(GLUnurbs *nobj, const char* file, int line);
#ifndef gluEndPolygon
#define gluEndPolygon(tess) glatter_gluEndPolygon_debug((tess), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluEndPolygon_debug(GLUtesselator *tess, const char* file, int line);
#ifndef gluEndSurface
#define gluEndSurface(nobj) glatter_gluEndSurface_debug((nobj), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluEndSurface_debug(GLUnurbs *nobj, const char* file, int line);
#ifndef gluEndTrim
#define gluEndTrim(nobj) glatter_gluEndTrim_debug((nobj), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluEndTrim_debug(GLUnurbs *nobj, const char* file, int line);
#ifndef gluErrorString
#define gluErrorString(errCode) glatter_gluErrorString_debug((errCode), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT const GLubyte* glatter_gluErrorString_debug(GLenum errCode, const char* file, int line);
#ifndef gluErrorUnicodeStringEXT
#define gluErrorUnicodeStringEXT(errCode) glatter_gluErrorUnicodeStringEXT_debug((errCode), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT const wchar_t* glatter_gluErrorUnicodeStringEXT_debug(GLenum errCode, const char* file, int line);
#ifndef gluGetString
#define gluGetString(name) glatter_gluGetString_debug((name), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT const GLubyte* glatter_gluGetString_debug(GLenum name, const char* file, int line);
#ifndef gluGetTessProperty
#define gluGetTessProperty(tess, which, value) glatter_gluGetTessProperty_debug((tess), (which), (value), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluGetTessProperty_debug(GLUtesselator *tess, GLenum which, GLdouble *value, const char* file, int line);
#ifndef gluLookAt
#define gluLookAt(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz) glatter_gluLookAt_debug((eyex), (eyey), (eyez), (centerx), (centery), (centerz), (upx), (upy), (upz), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluLookAt_debug(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx, GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz, const char* file, int line);
#ifndef gluNewNurbsRenderer
#define gluNewNurbsRenderer() glatter_gluNewNurbsRenderer_debug(__FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT GLUnurbs* glatter_gluNewNurbsRenderer_debug(const char* file, int line);
#ifndef gluNewQuadric
#define gluNewQuadric() glatter_gluNewQuadric_debug(__FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT GLUquadric* glatter_gluNewQuadric_debug(const char* file, int line);
#ifndef gluNewTess
#define gluNewTess() glatter_gluNewTess_debug(__FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT GLUtesselator* glatter_gluNewTess_debug(const char* file, int line);
#ifndef gluNextContour
#define gluNextContour(tess, type) glatter_gluNextContour_debug((tess), (type), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluNextContour_debug(GLUtesselator *tess, GLenum type, const char* file, int line);
#ifndef gluNurbsCurve
#define gluNurbsCurve(nobj, nknots, knot, stride, ctlarray, order, type) glatter_gluNurbsCurve_debug((nobj), (nknots), (knot), (stride), (ctlarray), (order), (type), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluNurbsCurve_debug(GLUnurbs *nobj, GLint nknots, GLfloat *knot, GLint stride, GLfloat *ctlarray, GLint order, GLenum type, const char* file, int line);
#ifndef gluOrtho2D
#define gluOrtho2D(left, right, bottom, top) glatter_gluOrtho2D_debug((left), (right), (bottom), (top), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluOrtho2D_debug(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, const char* file, int line);
#ifndef gluPartialDisk
#define gluPartialDisk(qobj, innerRadius, outerRadius, slices, loops, startAngle, sweepAngle) glatter_gluPartialDisk_debug((qobj), (innerRadius), (outerRadius), (slices), (loops), (startAngle), (sweepAngle), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluPartialDisk_debug(GLUquadric *qobj, GLdouble innerRadius, GLdouble outerRadius, GLint slices, GLint loops, GLdouble startAngle, GLdouble sweepAngle, const char* file, int line);
#ifndef gluPerspective
#define gluPerspective(fovy, aspect, zNear, zFar) glatter_gluPerspective_debug((fovy), (aspect), (zNear), (zFar), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluPerspective_debug(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar, const char* file, int line);
#ifndef gluPickMatrix
#define gluPickMatrix(x, y, width, height, viewport) glatter_gluPickMatrix_debug((x), (y), (width), (height), (viewport), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluPickMatrix_debug(GLdouble x, GLdouble y, GLdouble width, GLdouble height, GLint viewport[4], const char* file, int line);
#ifndef gluProject
#define gluProject(objx, objy, objz, modelMatrix, projMatrix, viewport, winx, winy, winz) glatter_gluProject_debug((objx), (objy), (objz), (modelMatrix), (projMatrix), (viewport), (winx), (winy), (winz), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT int glatter_gluProject_debug(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *winx, GLdouble *winy, GLdouble *winz, const char* file, int line);
#ifndef gluPwlCurve
#define gluPwlCurve(nobj, count, array, stride, type) glatter_gluPwlCurve_debug((nobj), (count), (array), (stride), (type), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluPwlCurve_debug(GLUnurbs *nobj, GLint count, GLfloat *array, GLint stride, GLenum type, const char* file, int line);
#ifndef gluQuadricCallback
#define gluQuadricCallback(qobj, which, fn) glatter_gluQuadricCallback_debug((qobj), (which), (fn), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluQuadricCallback_debug(GLUquadric *qobj, GLenum which, void (CALLBACK* fn)(), const char* file, int line);
#ifndef gluQuadricDrawStyle
#define gluQuadricDrawStyle(quadObject, drawStyle) glatter_gluQuadricDrawStyle_debug((quadObject), (drawStyle), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluQuadricDrawStyle_debug(GLUquadric *quadObject, GLenum drawStyle, const char* file, int line);
#ifndef gluQuadricNormals
#define gluQuadricNormals(quadObject, normals) glatter_gluQuadricNormals_debug((quadObject), (normals), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluQuadricNormals_debug(GLUquadric *quadObject, GLenum normals, const char* file, int line);
#ifndef gluQuadricOrientation
#define gluQuadricOrientation(quadObject, orientation) glatter_gluQuadricOrientation_debug((quadObject), (orientation), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluQuadricOrientation_debug(GLUquadric *quadObject, GLenum orientation, const char* file, int line);
#ifndef gluQuadricTexture
#define gluQuadricTexture(quadObject, textureCoords) glatter_gluQuadricTexture_debug((quadObject), (textureCoords), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluQuadricTexture_debug(GLUquadric *quadObject, GLboolean textureCoords, const char* file, int line);
#ifndef gluScaleImage
#define gluScaleImage(format, widthin, heightin, typein, datain, widthout, heightout, typeout, dataout) glatter_gluScaleImage_debug((format), (widthin), (heightin), (typein), (datain), (widthout), (heightout), (typeout), (dataout), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT int glatter_gluScaleImage_debug(GLenum format, GLint widthin, GLint heightin, GLenum typein, const void *datain, GLint widthout, GLint heightout, GLenum typeout, void *dataout, const char* file, int line);
#ifndef gluSphere
#define gluSphere(qobj, radius, slices, stacks) glatter_gluSphere_debug((qobj), (radius), (slices), (stacks), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluSphere_debug(GLUquadric *qobj, GLdouble radius, GLint slices, GLint stacks, const char* file, int line);
#ifndef gluTessBeginContour
#define gluTessBeginContour(tess) glatter_gluTessBeginContour_debug((tess), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluTessBeginContour_debug(GLUtesselator *tess, const char* file, int line);
#ifndef gluTessBeginPolygon
#define gluTessBeginPolygon(tess, polygon_data) glatter_gluTessBeginPolygon_debug((tess), (polygon_data), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluTessBeginPolygon_debug(GLUtesselator *tess, void *polygon_data, const char* file, int line);
#ifndef gluTessCallback
#define gluTessCallback(tess, which, fn) glatter_gluTessCallback_debug((tess), (which), (fn), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluTessCallback_debug(GLUtesselator *tess, GLenum which, void (CALLBACK *fn)(), const char* file, int line);
#ifndef gluTessEndContour
#define gluTessEndContour(tess) glatter_gluTessEndContour_debug((tess), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluTessEndContour_debug(GLUtesselator *tess, const char* file, int line);
#ifndef gluTessEndPolygon
#define gluTessEndPolygon(tess) glatter_gluTessEndPolygon_debug((tess), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluTessEndPolygon_debug(GLUtesselator *tess, const char* file, int line);
#ifndef gluTessNormal
#define gluTessNormal(tess, x, y, z) glatter_gluTessNormal_debug((tess), (x), (y), (z), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluTessNormal_debug(GLUtesselator *tess, GLdouble x, GLdouble y, GLdouble z, const char* file, int line);
#ifndef gluTessProperty
#define gluTessProperty(tess, which, value) glatter_gluTessProperty_debug((tess), (which), (value), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluTessProperty_debug(GLUtesselator *tess, GLenum which, GLdouble value, const char* file, int line);
#ifndef gluTessVertex
#define gluTessVertex(tess, coords, data) glatter_gluTessVertex_debug((tess), (coords), (data), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT void glatter_gluTessVertex_debug(GLUtesselator *tess, GLdouble coords[3], void *data, const char* file, int line);
#ifndef gluUnProject
#define gluUnProject(winx, winy, winz, modelMatrix, projMatrix, viewport, objx, objy, objz) glatter_gluUnProject_debug((winx), (winy), (winz), (modelMatrix), (projMatrix), (viewport), (objx), (objy), (objz), __FILE__, __LINE__)
#endif
GLATTER_INLINE_OR_NOT int glatter_gluUnProject_debug(GLdouble winx, GLdouble winy, GLdouble winz, const GLdouble modelMatrix[16], const GLdouble projMatrix[16], const GLint viewport[4], GLdouble *objx, GLdouble *objy, GLdouble *objz, const char* file, int line);
#endif // defined(__glu_h__)
#endif // defined(__GLU_H__)
#endif // GLATTER_GLU

